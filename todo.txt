
#goals get a web server install up
#install queu dir
#Create IPC system
#Restart Server Command
#Test non block
#See server Uptime (JSON result)
#Create queues (local and other)
#See Queue List (JSON result)
#Change queue process name
#Fix bug with spaces in queue names and script names
#Detect queue death and restart
#Have QueueSupervisor shut down children upon shutdown
#Git checkin
#Lite Click on queues to dig deeper
  + main page has links
  + queue page has info

Monday
------
#Add to git.btrll.com repo
+Queue status
  + store status
  + return status
  + Lite-web queue process restart (hit a link, does restart, says
  'OK', you hit back button)

+QueueSupervisor state
  + Try to start queues (just start any queue with a dir)

+Lite Queue startup -> verify dirs -> loads state (operational status)
?Move administrative state to queuemgr
 - Maybe queue process is always up, though?, yeah, quemgr just loads
 procs
  
+ Identify message ID and attribs, make an object
+ Lite queue message manipulation
  + inject message
  - delete message
+Have Queue show num messages in store
+Have Queue show list of messages in store
+Lite Have a message data store (ordered)

Tuesday
-------
+ Design doc -> simple supervisor model, simple understanding of locking
+ Children detect parent death and die
+ Multiple queue dirs
    ['_lock', 'w'], -> lockfile for queue
    ['_log',  'w'],
    ['_tmp',  'd'],
    ['prep',  'd'], -> prep
    ['que',   'd'], -> queued
    ['run',   'd'], -> running (for a 1 worker queue, 1 at a time)
    ['pause', 'd'], -> running (for a 1 worker queue, 1 at a time)
    ['done',  'd'], -> done (removed, errored and removed, etc)
    ['_err',  'd'], -> error (malformed, unfinished?)
?A New FileQue class

+Sleep random for inject
+Change 'queue' to 'q' in message id and url
+Change 'messages' status to show all q's
-Have q inject go to actual q
 - change form
 - change controller
 - change mesg_id code
 - relay pointer record
- Reverse presentation of messages in a queue

Queue a job via cmd line (using ruby lib)
  - simple message
  - file attachment via same filesystem (check stat.dev for equality)
  - file attachment via diff filesystem (make a temp file, copy file)
Lite delete message
Lite show message
Message list has length param for packet length on both sides
View queue log
View mesg log

*milestone*

Have a local queue script deliver message to a local queue
 - run a script in an environment
 - record redirect
 - local queue on same host
 - remote queue on other host
   - network listener
   - ruby lib to talk protocol 

Have a local queue script deliver message to a remote queue
 - setup socket listener
 - remote queue on other host
   - network listener
   - ruby lib to talk protocol 

View queue log
Lite queue mod administrative and operational state
 - Set to up or down

Implement CDB push system
 - Delivers to local
 - Relayed to cdb_push script
 - cdb_push creates new cdb file
 - cdb_push preps new messages to other machines
 - cdb_push waits for all messages to complete or errors out
 - remote machines script moves file into proper location as proper user

Later...
Implement lock files for all queues.
Have TMS keep track of last 3 completed jobs per user (in session)
Have TMS keep track of active jobs
-Message list has length param for packet length on both sides

Control queue states (clean shutdown, hold, go)
Refactor Quemgr to be like queue

Have a script for another queue (cdb push)

Have a local queue script move job to a remote queue

DONE

Restart Server Command via web
View log via web (last 10 entries)
#  Simple IPC via cmd line or web to running process
#    Core is Unix Domain, Web Proxies
Have the queue send job to destination queue (local machine, local filesystem)
Have remote queue deliver
Have remote queue run
